import random
import string
import base64
import ast # Abstract Syntax Tree para un análisis más robusto (aunque aquí lo usaremos de forma simple)
import os # Para manejo de paths

def generate_random_name(length=8):
    """Genera un nombre aleatorio para variables/funciones."""
    return "_" + "".join(random.choice(string.ascii_lowercase) for i in range(length))

def obfuscate_variables_and_functions(code_content):
    """Identifica nombres usando AST y luego los reemplaza en el texto del código."""
    obfuscated_code = code_content
    name_map = {}

    try:
        tree = ast.parse(code_content)
        local_names_in_functions = {} # Para rastrear variables locales por función

        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # Renombrar nombre de función (global)
                if node.name not in name_map and not node.name.startswith("__"):
                    name_map[node.name] = generate_random_name()
                # Renombrar argumentos de la función (local a la función)
                current_func_local_names = set()
                for arg in node.args.args:
                    if arg.arg not in name_map: # Los args son locales
                        name_map[arg.arg] = generate_random_name()
                    current_func_local_names.add(arg.arg)
                # Recolectar variables locales dentro de esta función
                for sub_node in ast.walk(node): # Solo caminar dentro del nodo de la función
                    if isinstance(sub_node, ast.Assign):
                        for target in sub_node.targets:
                            if isinstance(target, ast.Name) and target.id not in name_map:
                                name_map[target.id] = generate_random_name()
                                current_func_local_names.add(target.id)
                local_names_in_functions[node.name] = current_func_local_names

        # Recolectar variables globales (asignaciones fuera de funciones)
        for node in tree.body: # Solo nodos de primer nivel del módulo
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and target.id not in name_map:
                        name_map[target.id] = generate_random_name()

        # Aplicar los renombres (de más largo a más corto para evitar reemplazos parciales)
        # Esta es la parte más débil; el reemplazo de texto puede fallar en casos complejos.
        # Un AST rewriter sería la solución robusta.
        sorted_names = sorted(name_map.keys(), key=len, reverse=True)
        for old_name in sorted_names:
            # Intentar ser un poco más cuidadoso con el reemplazo usando regex con word boundaries
            # Esto aún no es perfecto para todos los contextos de Python.
            try:
                obfuscated_code = obfuscated_code.replace(old_name, name_map[old_name])
            except Exception as e:
                 print(f"Error reemplazando {old_name}: {e}")

    except SyntaxError as e:
        print(f"Error de sintaxis al parsear el código para renombrar: {e}")
        print("Renombrado de variables/funciones podría ser incompleto o incorrecto.")

    return obfuscated_code, name_map

def encode_strings_in_code(code_content, name_map):
    """Encuentra strings literales usando AST y los codifica en base64."""
    obfuscated_code = code_content
    if "import base64" not in obfuscated_code.split("\\n")[0]: # Chequear si ya está importado
        obfuscated_code = "import base64\\n" + obfuscated_code

    strings_to_encode_positions = [] # Almacenar (start_offset, end_offset, value)
    try:
        tree = ast.parse(obfuscated_code)
        for node in ast.walk(tree):
            if isinstance(node, ast.Constant) and isinstance(node.value, str):
                if len(node.value) > 1 and node.value not in name_map.values() and not node.value.startswith("_") and "utf-8" not in node.value and "base64" not in node.value:
                    # Usar col_offset y end_col_offset para obtener la posición exacta del string
                    # Esto es más complejo porque necesitamos mapear offsets a posiciones en el string original.
                    # Por simplicidad para este ejemplo, seguiremos reemplazando basado en valor, pero marcamos la limitación.
                    strings_to_encode_positions.append(node.value) # Simplificado: solo el valor

    except Exception as e:
        print(f"Error parseando código para codificación de strings: {e}. Se omite la codificación de strings.")
        return obfuscated_code

    # Reemplazar de más largo a más corto para evitar problemas de subcadenas
    unique_strings = sorted(list(set(strings_to_encode_positions)), key=len, reverse=True)

    for s_val in unique_strings:
        encoded_s = base64.b64encode(s_val.encode("utf-8")).decode("utf-8")
        # Usar repr() para obtener la representación del string tal como estaría en el código (ej. con sus comillas)
        original_string_repr = repr(s_val)
        replacement_string = fbase64.b64decode("{encoded_s}").decode("utf-8")
        obfuscated_code = obfuscated_code.replace(original_string_repr, replacement_string)

    return obfuscated_code

def insert_dead_code(code_content, num_insertions=3):
    """Inserta código muerto simple en el script."""
    lines = code_content.split("\\n")
    for _ in range(num_insertions):
        var_name = generate_random_name()
        dead_code_options = [
            f"{var_name} = {random.randint(1000, 9999)} * {random.randint(1000, 9999)} # dc",
            f"if False: print(\\"Dead code {var_name}\\") # dc",
            f"def {var_name}(): pass # dc"
        ]
        chosen_dead_code = random.choice(dead_code_options)
        possible_indices = [i for i, line in enumerate(lines) if line.strip() and not line.strip().startswith("#")]
        if possible_indices:
            insert_index = random.choice(possible_indices)
            indentation = lines[insert_index][:len(lines[insert_index]) - len(lines[insert_index].lstrip())]
            lines.insert(insert_index, indentation + chosen_dead_code)
    return "\\n".join(lines)

def remove_comments_and_empty_lines(code_content):
    """Elimina comentarios de línea completa y líneas vacías."""
    lines = code_content.split("\\n")
    cleaned_lines = []
    for line in lines:
        stripped_line = line.strip()
        if stripped_line and not stripped_line.startswith("#"):
            # También eliminar comentarios al final de la línea
            line_no_inline_comment = line.split("#", 1)[0].rstrip()
            if line_no_inline_comment:
                 cleaned_lines.append(line_no_inline_comment)
    return "\\n".join(cleaned_lines)

if __name__ == "__main__":
    # Definir rutas relativas al script actual para portabilidad
    script_dir = os.path.dirname(__file__)
    input_script_path = os.path.join(script_dir, "sample_script_to_obfuscate.py")
    output_script_path = os.path.join(script_dir, "obfuscated_script.py")

    try:
        with open(input_script_path, "r", encoding="utf-8") as f:
            original_code = f.read()
    except FileNotFoundError:
        print(f"Error: El archivo de entrada {input_script_path} no fue encontrado.")
        exit()

    print(f"--- Código Original ({os.path.basename(input_script_path)}) ---")
    print(original_code)

    # 1. Eliminar comentarios y líneas vacías
    cleaned_code = remove_comments_and_empty_lines(original_code)

    # 2. Renombrar variables y funciones
    code_after_renaming, name_map = obfuscate_variables_and_functions(cleaned_code)
    print("\n--- Mapa de Renombres (para referencia) ---")
    for old, new in name_map.items(): print(f"    {old} -> {new}")

    # 3. Codificar strings (después de renombrar para no afectar nombres)
    code_after_string_encoding = encode_strings_in_code(code_after_renaming, name_map)

    # 4. Insertar código muerto
    final_obfuscated_code = insert_dead_code(code_after_string_encoding)

    print(f"\n--- Código Ofuscado ({os.path.basename(output_script_path)}) ---")
    print(final_obfuscated_code)

    try:
        with open(output_script_path, "w", encoding="utf-8") as f:
            f.write(final_obfuscated_code)
        print(f"\nScript ofuscado guardado en: {output_script_path}")
    except IOError as e:
        print(f"Error al escribir el archivo de salida: {e}")
